<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<!-- 		<script src="plugin/markdown/marked.js"></script>
		<script src="plugin/markdown/markdown.js"></script> -->
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<link rel="stylesheet" href="css/my.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>Problem
			
				<p>

					Starting in the top left corner of a 2Ã—2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.
				</p>
		<div style="center">
						<canvas id="canvas" width="400" height="400" style="position: absolute; left: 0; top: 300pt; z-index: 1;">
						</canvas>
						<canvas id="grid" width="400" height="400" style="position: absolute; left: 0; top: 300pt; z-index: 0;">
						</canvas>
						<canvas id="canvas2" width="400" height="400" style="position: absolute; left: 300; top: 300pt; z-index: 1;">
						</canvas>
						<canvas id="grid2" width="400" height="400" style="position: absolute; left: 300; top: 300pt; z-index: 0;">
						</canvas>						
			
		</div>
		<script>
var canvas = document.getElementById('canvas');
			var ctx = canvas.getContext('2d');
			ctx.fillStyle = 'rgb(255,255,255)'; 
			var start = null;
					let state = {
						pattern: ['L', 'diagonal'],
					}
			function initState(){
				state = {
					x:0,
					y:0,
					chunkX: 0,
					chunkY: 0, 
					duration: 10,
					xProg: 0,
					yProg: 0,
					drawingDir : null,
					curPat :'L',
					pattern : state.pattern,
					swapPat: false
				}
				ctx.moveTo(state.x , state.y );
			}
			// function initTransState(){
			// 	// set the progress dims to 0
			// 	state.xProg = 0 
			// 	state.yProg = 0
			// }
			function loop(timestamp){
			 	if (!start) start = timestamp;
			 	var duration = timestamp - start;	

				// ctx.save()
				// ctx = canvas./getContext('2d');
				ctx.beginPath();
				ctx.moveTo(state.x , state.y );
				switch(state.curPat){
					case "L":
						if(state.drawingDir == "x"){
							state.xProg = (duration) / 10
							state.x = state.chunkX * 50 + state.xProg
							if (state.xProg >= 40 * 5 ){
								state.chunkX ++
								state.xProg = 1
								state.drawingDir = "y"
								start = 0 
								}
						}else{
							state.yProg =   (duration) / 10
							state.y = state.chunkY * 50 + state.yProg
							if (state.yProg >= 40 * 5){
								state.chunkY ++
								state.yProg = 1 
								state.drawingDir = "x"
								start = 0
							}
						}
						if(state.chunkX >= 1 && state.chunkY >= 1)
							state.swapPat = true
						break;
					case "diagonal":
						if(state.drawingDir == "x"){
							state.xProg = (duration) / 10
							state.x = state.chunkX * 50 + state.xProg
							if (state.xProg >= 50 ){
								state.chunkX ++
								state.xProg = 1
								state.drawingDir = "y"
								start = 0 
								}
							}else{
								state.yProg =   (duration) / 10
								state.y = state.chunkY * 50 + state.yProg
								if (state.yProg >= 50 ){
									state.chunkY ++
									state.yProg = 1 
									state.drawingDir = "x"
									start = 0
								}
							}
						if(state.chunkX > 5 || state.chunkY > 5)
							state.swapPat = true
						break;
				}
				console.log(state.x, state.y)
				if(state.swapPat){
					initState()
					state.swapPat = false
					state.curPat = state.pattern.pop()
					window.requestAnimationFrame(loop)
					return
				}else{
					ctx.lineTo(state.x, state.y );	
					ctx.strokeStyle = "white"
					ctx.stroke();
				}
				if (duration > 500000 || state.pattern.length == 0)
					return 
				window.requestAnimationFrame(loop)
			}
			initState()
			function drawSteps(gridSize, rights, downs, timestamp){
				//inverse orders rights and downs
				downs.sort((a, b) => b - a)
				rights.sort((a, b) => b - a)
				// rights = [2,2]
				// then down, right,right, down
				//    1   2   3   4
				// 1  |
				//    V
				// 2    --> -->  |
				//			     V 
				
			 	if (!start) start = timestamp;
			 	let duration = timestamp - start;	

				ctx.beginPath();
				ctx.moveTo(state.x , state.y );

				let curRight =  rights[rights.length -1 ] //TODO change so can include 1 length arrays
				let curDown = downs[downs.length - 1]
				state.drawingDir = state.drawingDir  || (curDown > curRight ? 'x': 'y')
				// while (rights.length > 0 && downs.length > 0){
					if(state.drawingDir == "x"){
						state.xProg = (duration) / 80
						state.x = state.chunkX * 50 + state.xProg
						if(state.chunkX >= curDown - 1){
							//switch directions because we hit a point where the 
							// other DIM should change
							state.drawingDir = "y"
							curDown = rights.pop()
							start = timestamp
							return {"rights": rights, "downs": downs}
						}
						if (state.xProg >= 50 ){
							// we reached a new chuck
							// reset duration by restting start
							// and iterate this DIM's chunk 
							state.xProg = 1
							start = timestamp 
							state.chunkX ++
							state.drawingDir = (curDown > curRight ? 'x': 'y')
						}
					}else if (state.drawingDir === 'y'){
						state.yProg =   (duration) / 80
						state.y = state.chunkY * 50 + state.yProg
						if(state.chunkY >= curRight - 1)
						{//switch direction to X
							state.drawingDir = "x"
							curRight = downs.pop()
							start = timestamp
							return {"rights": rights, "downs": downs}
						}
						if (state.yProg >= 50 ){
							state.chunkY ++
							start = timestamp
							state.yProg = 1 
							state.drawingDir = (curDown > curRight ? 'x': 'y')	
						}
					}else{
						console.log("i love j")
					}
				if(state.chunkX >= 5 && state.drawingDir === 'x'){
					state.swapPat = true
					state.drawingDir = 'y'
					state = timestamp
					return {"rights": rights, "downs": downs}

				}else if (state.chunkY >= 5 && state.drawingDir === 'y'){
					state = timestamp
					state.drawingDir = 'x'
					state.swapPat = true
					return {"rights": rights, "downs": downs}
				}
			
				// }
				ctx.lineTo(state.x, state.y );	
				ctx.strokeStyle = "white"
				ctx.stroke();
				state.curPat = 'steps'
				return {"rights": rights, "downs": downs}
			}
			// window.requestAnimationFrame(loop)

			//test drawSteps
			let r = [2,2]
			let d = [1,4]
			let results = null
			function stepsLoop(timestamp){
				results = results || {}
				d = results.downs || d
				r = results.rights || r
				results= drawSteps(50, r ,d, timestamp)
				if (timestamp - start > 50000)
					return
				window.requestAnimationFrame(stepsLoop)
			}
			window.requestAnimationFrame(stepsLoop)
			// the render logic should be focusing on the rendering 
			var drawGrid = function(context, w, h, step) {
			    context.beginPath(); 
			    for (var x=0;x<=w;x+=step) {
			            context.moveTo(x, 0);
			            context.lineTo(x, h);
			    }
			   
			    context.strokeStyle = 'grey';
			    context.lineWidth = 3;
			    context.stroke(); 
			    context.beginPath(); 
			    for (var y=0;y<=h;y+=step) {
			            context.moveTo(0, y);
			            context.lineTo(w, y);
			    }

			    context.strokeStyle = 'grey';
			    context.lineWidth = 3
			    context.strokeStyle = "grey";
			    context.stroke(); 
			};
			var grid = document.getElementById('grid');
			var gridCtx = grid.getContext('2d');
			drawGrid(gridCtx, 200, 200, 50)
			ctx.strokeStyle = "white"	
			ctx.lineWidth = 8
			var grid2 = document.getElementById('grid2');
			var grid2Ctx = grid2.getContext('2d');
			drawGrid(grid2Ctx, 200, 200, 50)
		</script>
	</body>
</html>
