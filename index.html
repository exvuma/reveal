<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<!-- 		<script src="plugin/markdown/marked.js"></script>
		<script src="plugin/markdown/markdown.js"></script> -->
		<!-- Printing and PDF exports -->
		<script>
			let link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<link rel="stylesheet" href="css/my.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>Problem

				<p>

					Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.
				</p>
				<canvas id="arrow" width="350" height="350" style="position: absolute; left: 0; top: 250pt; z-index: 10;">
				</canvas>
		<div style="center">
						<canvas id="canvas" width="400" height="400" style="position: absolute; left: 0; top: 300pt; z-index: 1;">
						</canvas>
						<canvas id="grid" width="400" height="400" style="position: absolute; left: 0; top: 300pt; z-index: 0;">
						</canvas>
						<canvas id="canvas2" width="400" height="400" style="position: absolute; left: 300; top: 300pt; z-index: 1;">
						</canvas>
						<canvas id="grid2" width="400" height="400" style="position: absolute; left: 300; top: 300pt; z-index: 0;">
						</canvas>

		</div>

					How many such routes are there through a 20×20 grid?
				</section>
				<section>Slide 2
					<code >2(n-n-1) + <span id="po">2(n-2)</span> + ...+ 2(n-1)</code>
				</section>
				<section data-markdown >
						## Page title

						A paragraph with some text and a [link](http://hakim.se).

						```2(n-n-1) + 2(n-2) + ...+ 2(n-1)
						```

				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				math: {
						mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
						config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
					},
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/math/math.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
					]
				});
			Reveal.configure({
  				keyboard: {
  					13: function() {
  						console.log("Enter Pressed hit")
  						let el = document.querySelectorAll("#po")[0].innerText="ESC hit"
  					}
  				}
  				});
			///////////////////////////////////////////////////
			///////////////// Global Varibles /////////////////
			///////////////////////////////////////////////////
			const speed = 3;
			let start = null;

			 // state = {
				// 		pattern: ['L', 'diagonal'],
				// 	}
			// let state.curRight, state.curDown = null;
			///////////////////////////////////////////////////
			///////////////// Functions  /////////////////
			///////////////////////////////////////////////////

			function initState(){
				return{
					x:0,
					y:0,
					chunkX: 0,
					chunkY: 0,
					duration: 10,
					xProg: 0,
					yProg: 0,
					drawingDir : null,
					curPat :'L',
					// pattern : state.pattern,
					curRight: null,//the next right in the rights arr that we haven't chunked yet
					curDown:null
					// swapPat: false
				}
				ctx.moveTo(state.x , state.y );
				return state
			}
			function drawSteps(gridSize, rights, downs, timestamp, n){
				//inverse orders rights and downs
				downs.sort((a, b) => b - a)
				rights.sort((a, b) => b - a)
				// rights = [2,2]
				// then down, right,right, down
				//    1     2
				// 1  |
				//    V
				// 2  --> -->|
				//			     V

			 	if (!start) start = timestamp;
			 	const duration = timestamp - start;
				ctx.beginPath();
				ctx.moveTo(state.x , state.y );
				state.curDown = state.curDown || downs.pop() || 0
				state.curRight = state.curRight || rights.pop() || 0
				state.drawingDir = state.drawingDir  || (state.curDown >= state.curRight ? 'x': 'y')
				if(state.curRight === 0 || state.chunkX > n) state.drawingDir = 'y'
				if(state.curDown === 0 || state.chunkY > n) state.drawingDir = 'x'
					if(state.drawingDir == "x"){
						state.xProg = (duration) / speed
						state.x = state.chunkX * 100 + state.xProg
						// if(state.chunkX >= state.curDown - 1){
						// 	//switch directions because we hit a point where the
						// 	// other DIM should change

						if(state.xProg > 100){
							// we reached a new chuck
							// reset duration by restting start
							// and iterate this DIM's chunk
							state.curRight =  rights.pop() ||  0
							// if(rights.length === 0) state.curRight = 0
							// console.log("about to pop rights")
							// console.log( rights)
					//		r
							state.chunkX ++
							// if(state.curDown === 0 )
							state.drawingDir = (state.curDown > state.curRight ? 'x': 'y')
							start = timestamp
						}
					}else if (state.drawingDir === 'y'){
						state.yProg =   (duration) / speed
						state.y = state.chunkY * 100 + state.yProg
						if(state.yProg > 100 ){// IF very close to a multiple of 50 Math.floor
							state.chunkY ++
							// console.log("about to pop downs")
							// console.log( downs)
							state.curDown =  downs.pop() || 0
							// if(downs.length === 0) state.curDown = 0
							state.drawingDir = (state.curDown >= state.curRight ? 'x': 'y')
							start = timestamp
						}
					}
				ctx.lineTo(state.x, state.y );
				// console.log(state.x, state.y)
				ctx.strokeStyle = "white"
				ctx.stroke();
				state.curPat = 'steps'
				return {"rights": rights, "downs": downs}
			}
			// window.requestAnimationFrame(loop)
			function convertRightsToDowns(input_rights){
				let numRights = 1//number of consecutive
				let prevRight = input_rights[0]
				let totalRights = 0 // the number we will start down at
				let numDowns
				let downs = []
				if (!input_rights) return null
				if(input_rights.length === 0 ) return []
				for (let i = 1; i < input_rights.length ; i++) {
					totalRights = i + 1
					if(input_rights[i] === input_rights[i-1]){
						prevRight = input_rights[i]
						numRights ++
					}
					else{
						numDowns = input_rights[i] - prevRight

						if(numDowns < 0) return []//"invalid input_rights entered"
						for(let j = 0 ; j < numDowns; j++)
							downs.push(totalRights)
					}
					prevRight = input_rights[i]
				}
				if(downs.length < input_rights.length){
					for (let i = downs.length; i < input_rights.length; i++) {
							if(input_rights[i] >= input_rights.length ) downs.push(1)
							else{

								downs.push( input_rights.length + 1)
						}
					}
				}
				return downs
			}
			function stepsLoop(timestamp){

				results = results || {}
				if(!results.rights) //|| (results.rights && !results.rights.length))
				{//if we haven't started yet
					results.rights = smallRights.pop()
				}
				else {
						// r = results.rights
				}
				// if(results.rights && results.rights.length === 0 && results.downs.length === 0)
				// 	results.rights = rights.pop()
				results.downs = results.downs || convertRightsToDowns(results.rights)
				// console.log("rights", r)
				// console.log("downs", d)
				if( (!results.downs || results.downs.length === 0) &&( !results.rights || results.rights.length === 0) && (state.chunkX >= n && state.chunkY >= n )) {
					//start over
					results = null
					start = timestamp
					Object.assign( state, initState())
				}
				else{
					results = drawSteps(50,results.rights, results.downs, timestamp, n)
				}
				clearArrow(arrowCtx, arrow)
				placeArrow(arrowCtx, state.x, state.y +55)
				if(state.chunkX > n && state.chunkY > n)
					{
						results = null
						start = timestamp
						Object.assign( state, initState())
				}

				if(smallRights.length === 0) return
					// console.log("should i return here")
				window.requestAnimationFrame(stepsLoop)
				if (timestamp - start > 50000)
					return
			}
			function placeArrow(ctx, x, y){
				// if (canvas.getContext) {
				// letctx = canvas.getContext('2d');

				ctx.beginPath();
				base = 0
				ctx.moveTo(base + x, base+y);
				ctx.lineTo(base + x, base+24+y);
				ctx.lineTo(base + 15+x, base+12+y);
				ctx.strokeStyle = "white"
				ctx.fillStyle = "white"
				// ctx.stroke();
				ctx.fill();

			}
			function clearArrow(ctx,canvas){
				// ctx.clearRect(x, y, width, height)//
				ctx.clearRect(0,0,canvas.width, canvas.height)

				// x	Clear rectangle x position
				// y	Clear rectangle y position
				// width	Clear rectangle width
				// height	Clear rectangle height

			}
			function drawGrid (context, w, h, step) {
				context.beginPath();
				for (let x=0;x<=w;x+=step) {
					context.moveTo(x, 0);
					context.lineTo(x, h);
				}

				context.strokeStyle = 'grey';
				context.lineWidth = 3;
				context.stroke();
				context.beginPath();
				for (let y=0;y<=h;y+=step) {
					context.moveTo(0, y);
					context.lineTo(w, y);
				}

				context.strokeStyle = 'grey';
				context.lineWidth = 3
				context.strokeStyle = "grey";
				context.stroke();
			};
			///////////////////////////////////////////////////
			///////////////// Main /////////////////
			///////////////////////////////////////////////////
			let RightsRev = [
					[1, 1, 1, 2],
					[1, 1, 1, 3],
					[1, 1, 1, 4],
					[1, 1, 1, 5],
					[1, 1, 2, 2],
					[1, 1, 2, 3],
					[1, 1, 2, 4],
					[1, 1, 2, 5],
					[1, 1, 3, 3],
					[1, 1, 3, 4],
					[1, 1, 3, 5],
					[1, 1, 4, 4],
					[1, 1, 4, 5],
					[1, 1, 5, 5],


					[1, 2, 2, 2],
					[1, 2, 2, 3],
					[1, 2, 2, 4],
					[1, 2, 2, 5],
					[1, 2, 3, 3],
					[1, 2, 3, 4],
					[1, 2, 3, 5],
					[1, 2, 4, 4],
					[1, 2, 4, 5],
					[1, 2, 5, 5]
				 ]//[) [1, 2, 5, 5]
				 const Rights =
				 [
					//  [1, 5, 4, 5],
					// [1, 5, 4, 5],
					// [1, 5, 4, 4],

				  	[1, 4, 4, 5],
					 [1, 4, 4, 5],
					 [1, 4, 4, 4],


					 [1, 3, 5, 5],
					 [1, 3, 4, 5],
					 [1, 3, 4, 4],
					 [1, 3, 3, 5],
					 [1, 3, 3, 4],
					 [1, 3, 3, 3],

					 [1, 2, 5, 5],
					 [1, 2, 4, 5],
					 [1, 2, 4, 4],
					 [1, 2, 3, 5],
					 [1, 2, 3, 4],
					 [1, 2, 3, 3],
					 [1, 2, 2, 5],
					 // [1, 2, 2, 4],
					 [1, 2, 2, 3],
					 [1, 2, 2, 2],


					 [1, 1, 5, 5],

					 [1, 1, 4, 5],
					 [1, 1, 4, 4],

					 // [1, 1, 3, 5],
					 // [1, 1, 3, 4],
					 [1, 1, 3, 3],

					 // [1, 1, 2, 5],
					 // [1, 1, 2, 4],
					 // [1, 1, 2, 3],
					 // [1, 1, 2, 2],

					 [1, 1, 1, 5],
					 [1, 1, 1, 4],
					 // [1, 1, 1, 3],
					 // [1, 1, 1, 2],
					 [1, 1, 1, 1],

				 ]
			// const Rights = RightsRev.map((el, i, arr) => {
			// 	let g = arr.length - i - 1
			// 	let t = arr[arr.length - i - 1]
			// 	return arr[arr.length - i - 1]
			// })
			const smallRights = [
				// [3,3,3],
				// [3,3,3],
				[3,3],
				// [2,2,2],
				// [3,3],
				[2,3],
				// [2,2,2],
				[2,2],
        // //
				[1,3],
				[1,2],
				[1,1],
			]
			const arrow = document.getElementById('arrow');
			let results = {}
			const canvas = document.getElementById('canvas');
			const ctx = canvas.getContext('2d');
			ctx.fillStyle = 'rgb(255,255,255)';
			const n = 2//results.rights.length
			const arrowCtx = arrow.getContext('2d');
			// results.rights = rights[0]

			const state = initState()
			let test = [1, 1, 3, 4]

			// the render logic should be focusing on the rendering

			placeArrow(arrowCtx, 200, 200, 50)
			let grid = document.getElementById('grid');
			let gridCtx = grid.getContext('2d');
			drawGrid(gridCtx, 200, 200, 100)
			ctx.strokeStyle = "white"
			ctx.lineWidth = 8

			const canvas2 = document.getElementById('canvas2');
			const ctx2= canvas.getContext('2d');
			let grid2 = document.getElementById('grid2');
			let grid2Ctx = grid2.getContext('2d');
			drawGrid(grid2Ctx, 200, 200, 100)
			window.requestAnimationFrame(stepsLoop,ctx)
			window.requestAnimationFrame(stepsLoop,ctx2)
		</script>
	</body>
</html>
