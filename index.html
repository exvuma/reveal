<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<!-- 		<script src="plugin/markdown/marked.js"></script>
		<script src="plugin/markdown/markdown.js"></script> -->
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<link rel="stylesheet" href="css/my.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>Problem

				<p>

					Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.
				</p>
		<div style="center">
						<canvas id="canvas" width="400" height="400" style="position: absolute; left: 0; top: 300pt; z-index: 1;">
						</canvas>
						<canvas id="grid" width="400" height="400" style="position: absolute; left: 0; top: 300pt; z-index: 0;">
						</canvas>
						<canvas id="arrow" width="400" height="400" style="position: absolute; left: 0; top: 300pt; z-index: 0;">
						</canvas>
						<canvas id="canvas2" width="400" height="400" style="position: absolute; left: 300; top: 300pt; z-index: 1;">
						</canvas>
						<canvas id="grid2" width="400" height="400" style="position: absolute; left: 300; top: 300pt; z-index: 0;">
						</canvas>

		</div>

					How many such routes are there through a 20×20 grid?
				</section>
				<section>Slide 2
					<code >2(n-n-1) + <span id="po">2(n-2)</span> + ...+ 2(n-1)</code>
				</section>
				<section data-markdown >
						## Page title

						A paragraph with some text and a [link](http://hakim.se).

						```2(n-n-1) + 2(n-2) + ...+ 2(n-1)
						```

				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			const speed = 3;
			Reveal.initialize({
				math: {
						mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
						config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
					},
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/math/math.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
					]
				});
			Reveal.configure({
  				keyboard: {
  					13: function() {
  						console.log("Enter Pressed hit")
  						let el = document.querySelectorAll("#po")[0].innerText="ESC hit"
  					}
  				}
  				});
			var canvas = document.getElementById('canvas');
			var ctx = canvas.getContext('2d');
			ctx.fillStyle = 'rgb(255,255,255)';
			let start = null;
			 state = {
						pattern: ['L', 'diagonal'],
					}
					let curRight, curDown = null;
			function initState(){
				state = {
					x:0,
					y:0,
					chunkX: 0,
					chunkY: 0,
					duration: 10,
					xProg: 0,
					yProg: 0,
					drawingDir : null,
					curPat :'L',
					pattern : state.pattern,
					swapPat: false
				}
				ctx.moveTo(state.x , state.y );
				curRight  = null
				curDown = null;
				return state
			}

			state = initState()
			function drawSteps(gridSize, rights, downs, timestamp){
				//inverse orders rights and downs
				downs.sort((a, b) => b - a)
				rights.sort((a, b) => b - a)
				// rights = [2,2]
				// then down, right,right, down
				//    1     2
				// 1  |
				//    V
				// 2  --> -->|
				//			     V

			 	if (!start) start = timestamp;
			 	let duration = timestamp - start;

				ctx.beginPath();
				ctx.moveTo(state.x , state.y );
				if(!curRight )
				 curRight = rights.pop() // the current right we are on from the array rights
				if(!curDown)
				 curDown = downs.pop()
				// let curRight =  rights[rights.length - 1 ] || Infinity//TODO change so can include 1 length arrays
				// let curDown = downs[downs.length - 1] || Infinity
				state.drawingDir = state.drawingDir  || (curDown > curRight ? 'x': 'y')
					if(state.drawingDir == "x"){
						state.xProg = (duration) / speed
						state.x = state.chunkX * 50 + state.xProg
						// if(state.chunkX >= curDown - 1){
						// 	//switch directions because we hit a point where the
						// 	// other DIM should change

						if(state.xProg > 50){
							// we reached a new chuck
							// reset duration by restting start
							// and iterate this DIM's chunk
							curRight =  rights[rights.length - 1 ] || Infinity
							rights.pop()
							state.chunkX ++
							state.drawingDir = (curDown > curRight ? 'x': 'y')
							start = timestamp
						}
					}else if (state.drawingDir === 'y'){
						state.yProg =   (duration) / speed
						state.y = state.chunkY * 50 + state.yProg
						if(state.yProg > 50 ){// IF very close to a multiple of 50 Math.floor
							state.chunkY ++

							curDown =  downs.pop() || Infinity
							state.drawingDir = (curDown > curRight ? 'x': 'y')
							start = timestamp
						}
					}
				ctx.lineTo(state.x, state.y );
				// console.log(state.x, state.y)
				ctx.strokeStyle = "white"
				ctx.stroke();
				state.curPat = 'steps'
				return {"rights": rights, "downs": downs}
			}
			// window.requestAnimationFrame(loop)
			function convertRightsToDowns(rights){
				let numRights = 1
				let prevRight = 0
				let totalRights = 0
				let numDowns
				let downs = []
				for (var i = 1; i < rights.length ; i++) {
					totalRights = i + 1
					if(rights[i] === rights[i-1]){
						prevRight = rights[i]
						numRights ++
					}
					else{
						numDowns = rights[i] - prevRight

						if(numDowns < 0) return "invalid rights entered"
						for(let j = 0 ; j < numDowns; j++)
							downs.push(totalRights)
					}
					prevRight = rights[i]
				}
				if(downs.length < rights.length){
					for (var i = downs.length; i < rights.length; i++) {
							if(rights[i] === rights.length +1) downs.push(1)
							else{

								downs.push( rights.length + 1)
						}
					}
				}
				return downs
			}
			let results = {}
				let rights = [
					[1, 1, 1, 1],
					[1, 1, 1, 2],
					[1, 1, 1, 3],
					[1, 1, 1, 4],
					[1, 1, 1, 5],
					[1, 1, 2, 2],
					[1, 1, 2, 3],
					[1, 1, 2, 4],
					[1, 1, 2, 5],
					[1, 1, 3, 3],
					[1, 1, 3, 4],
					[1, 1, 3, 5],
					[1, 1, 1, 1],
				]//[1,2, 3, 4]
				var arrow = document.getElementById('arrow');
				var arrowCtx = arrow.getContext('2d');
			results.rights = rights[0]
			let n = results.rights.length
			function stepsLoop(timestamp){

				results = results || {}
				r = results.rights || rights.pop()
				d = results.downs || convertRightsToDowns(r)

				results= drawSteps(50, r ,d, timestamp)
				clearArrow(arrowCtx, arrow)
				placeArrow(arrowCtx, state.x, state.y - 5 )
				if(state.chunkX >= n && state.chunkY >= n)
					{
						// pop from Rights
						results.rights = rights.pop() || []
						results.downs = convertRightsToDowns(results.rights)
						start = 0
						state = initState()
				}

				if(rights.length === 0)return
				window.requestAnimationFrame(stepsLoop)
				if (timestamp - start > 50000)
					return
			}
			window.requestAnimationFrame(stepsLoop)
			let test = [1, 1, 3, 4]

			// the render logic should be focusing on the rendering
			function placeArrow(ctx, x, y){
				// if (canvas.getContext) {
				// var ctx = canvas.getContext('2d');

				ctx.beginPath();
				base = 0
				ctx.moveTo(base + x, base+y);
				ctx.lineTo(base + x, base+24+y);
				ctx.lineTo(base + 15+x, base+12+y);
				ctx.strokeStyle = "white"
				ctx.fillStyle = "white"
				// ctx.stroke();
				ctx.fill();

			}
			function clearArrow(ctx,canvas){
				// ctx.clearRect(x, y, width, height)//
				ctx.clearRect(0,0,canvas.width, canvas.height)

// x	Clear rectangle x position
// y	Clear rectangle y position
// width	Clear rectangle width
// height	Clear rectangle height

			}

			placeArrow(arrowCtx, 200, 200, 50)
			var drawGrid = function(context, w, h, step) {
			    context.beginPath();
			    for (var x=0;x<=w;x+=step) {
			            context.moveTo(x, 0);
			            context.lineTo(x, h);
			    }

			    context.strokeStyle = 'grey';
			    context.lineWidth = 3;
			    context.stroke();
			    context.beginPath();
			    for (var y=0;y<=h;y+=step) {
			            context.moveTo(0, y);
			            context.lineTo(w, y);
			    }

			    context.strokeStyle = 'grey';
			    context.lineWidth = 3
			    context.strokeStyle = "grey";
			    context.stroke();
			};
			var grid = document.getElementById('grid');
			var gridCtx = grid.getContext('2d');
			drawGrid(gridCtx, 200, 200, 50)
			ctx.strokeStyle = "white"
			ctx.lineWidth = 8
			var grid2 = document.getElementById('grid2');
			var grid2Ctx = grid2.getContext('2d');
			drawGrid(grid2Ctx, 200, 200, 50)
		</script>
	</body>
</html>
